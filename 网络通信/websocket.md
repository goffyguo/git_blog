### 为什么webSocket没有被广泛的使用，它解决了前后端数据没有实时刷新的问题

为什么接口不全部采用websocket，最近在开发一个项目，里面有im实时聊天，用到了websocket，而我仅仅是聊天室用了，其他聊天记录已经人员邀请创建群里采取的都是http请求，数据需要实时交互目前前端实现方法就是类似于ajax轮询，定时请求接口数据，都知道这样一来比较浪费带宽，二来服务器端的压力会很大，所以在websocket出来前用的都是轮询，但websocket出来以后，按说解决了数据交互的问题，如果每个接口都做成websocket模式，岂不是不存在数据不刷新，都是实时显示的了，为什么http还没有被淘汰呢，原因就在于，既然他连接了不会断开，必然是后端那边用了某种方法来实现，而这个方法肯定是需要占用服务器的，我们这个聊天系统，光是后台去搭建就用了将近一周时间，可想而知这不是个简单的事情，但是单程的http请求一个接口写出来确是很快的，而且如果使用人员一多，同事建立多个websocket链接，若是一个数据改变，可能会向很多用户发送一次数据，这个数据量是庞大的，同样浪费带宽流量而且耗费服务器，所以不到万不得已，websocket是不会被建议使用的，除非你的某个数据很重要需要时时刻刻保存最新状态。

### 长连接和短连接

#### 误解

很久之前就听说过长连接的说法，而且还知道HTTP1.0协议不支持长连接，从HTTP1.1协议以后，连接默认都是长连接。但终究觉得对于长连接一直懵懵懂懂的，有种抓不到关键点的感觉。

今天通过一番研究，终于明白了这其中的奥秘。而之前，也看过长连接相关的内容，但一直都是云里雾里的。这次之所以能在这么短的时间里搞清楚，和自己技术的沉淀密不可分。因此，这里借着这个机会，再次强调一下，千万不要试图去研究你研究了很久都整不明白的东西，或许是你的层次不到，也或许是你从未在实际的应用场景接触过，这种情况下你去研究，只会事倍功半，徒劳一番罢了。

回到正题，既然说是误解，那么的误解到底是什么？

那就是一直认为，HTTP连接分为长连接和短连接，而我们现在常用的都是HTTP1.1，因此我们用的都是长连接。？？？

这句话其实只对了一半，我们现如今的HTTP协议，大部分都是1.1的，因此我们平时用的基本上都是长连接。

但是前半句是不对的，HTTP协议根本没有长短连接这一说，也正因为误解了这个，导致对于长连接一直不明不白，始终不得其要领，具体下面一段会说到。

网络上很多文章都是误人子弟，根本没有说明白这个概念。这里要强调一下，HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。

之所以网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。

其实知道了以后，会觉得这很好理解。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。

“HTTP连接”这个词就不应该出现，它只是一个应用层的协议，根本就没有所谓的连接这一说，就像FTP也是应用层的协议，但是你有听说过FTP连接吗？（恩，好像是听过，-_-，但你现在知道了，其实所谓的FTP连接，严格来说，依旧是TCP连接）

实际上，说HTTP请求和HTTP响应会更准确一些，而HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的。

> 不管怎么说，一定要务必记住，长连接是指的TCP连接，而不是HTTP连接。

#### 一个疑问

首先是怎么样就算是把HTTP变成长连接了，是不是只要设置Connection为keep-alive就算是了？

如果是的话，那都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接，但是长连接不是一般用于交互比较频繁的应用吗？像我们这种普通的Web应用，比如博客园这种，或者我的个人博客这种，长连接有什么用？

如果有用那用处到底是什么，我们又不是客户端与服务器交互频繁的那种应用（毕竟你打开网页肯定要半天才打开另外一个吧），如果没用的话，那到底应不应该把Connection为keep-alive这个header值给改掉，从而改成短连接？

其实明白了长连接其实是指TCP连接后，基本上就明白了。

长连接意味着连接会被复用，毕竟一直保持着连接不就是为了重复使用嘛。但如果长连接是指的HTTP的话，那就是说HTTP连接可以被重复利用，这个话听起来就感觉很别扭。

第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？

当然是的，但要服务器和客户端都设置。

第二个问题是，我们平时用的是不是长连接？

这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）。

第三个问题，就是我们这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？

首先，刚才已经说了，长连接是为了复用。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。

比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源可想而知。

但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。

另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。

这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？

#### **长轮询和短轮询**

这个时候，你会怎么做？

最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。

这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。

那怎么办呢？

长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。

而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。

这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。

但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。

因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。之所以举这个例子，只是因为大家肯定都会网购，所以这个例子比较通俗一点。

哪怕轮询解决不了获取库存这个问题，但只要大家明白了长短轮询的区别，这就足够了。实际上，据LZ自己平日里购物的观察，那个库存量应该是不会变的，这个例子纯属LZ个人的意淫，-_-。

#### **长短轮询和长短连接的区别**

这里简单说一下它们的区别，LZ这里只说最根本的区别。

第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。

第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的.

### **长连接与短连接**

TCP 本身并没有长短连接的区别，长短与否，完全取决于我们怎么用它。

- 短连接：每次通信时，创建 Socket;一次通信结束，调用 socket.close()。这就是一般意义上的短连接，短连接的好处是管理起来比较简单，存在的连接都是可用的连接，不需要额外的控制手段。
- 长连接：每次通信完毕后，不会关闭连接，这样就可以做到连接的复用。长连接的好处便是省去了创建连接的耗时。

短连接和长连接的优势，分别是对方的劣势。想要图简单，不追求高性能，使用短连接合适，这样我们就不需要操心连接状态的管理;想要追求性能，使用长连接，我们就需要担心各种问题：比如端对端连接的维护，连接的保活。

长连接还常常被用来做数据的推送，我们大多数时候对通信的认知还是 request/response 模型，但 TCP 双工通信的性质决定了它还可以被用来做双向通信。在长连接之下，可以很方便的实现 push 模型。

### 几种与服务器端实时通信的方式

不使用WebSocket与服务器实时交互，一般有两种方法。AJAX轮询和Long Polling长轮询。

#### **AJAX轮询**

AJAX轮询也就是定时发送请求，也就是普通的客户端与服务端通信过程，只不过是无限循环发送，这样，可以保证服务端一旦有最新消息，就可以被客户端获取。

#### **Long Polling长轮询**

Long Polling长轮询是客户端和浏览器保持一个长连接，等服务端有消息返回，断开。
然后再重新连接，也是个循环的过程，无穷尽也。。。

客户端发起一个Long Polling，服务端如果没有数据要返回的话，
会hold住请求，等到有数据，就会返回给客户端。客户端又会再次发起一次Long Polling，再重复一次上面的过程。

#### **缺点**

上边这两种方式都有个致命的弱点，开销太大，被动性。假设并发很高的话，这对服务端是个考验。
而WebSocket一次握手，持久连接，以及主动推送的特点可以解决上边的问题，又不至于损耗性能。

## websocket 心跳问题

TCP 协议自带了KeepAlive 为什么还要应用层做心跳？

TCP 用于检测连接的死活，而心跳机制则是附带一个额外的功能：检测通讯双方的存活状态

举例：某台服务器因为某些原因CPU100%，无法响应任何业务请求，使用使用TCP自带的探针仍然可以确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。

[不为人知的网络编程(十二)：彻底搞懂TCP协议层的KeepAlive保活机制-网络编程/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-3506-1-1.html)

心跳保活方案：

最简单粗暴做法当然是定时心跳，如每隔 30 秒心跳一次，15 秒内没有收到心跳回包则认为当前连接已失效，断开连接并进行重连。这种做法最直接，实现也简单。唯一的问题是比较耗电和耗流量。以一个协议包 5 个字节计算，一天收发 2880 个心跳包，一个月就是 5 * 2 * 2880 * 30 = 0.8 M 的流量，如果手机上多装几个 IM 软件，每个月光心跳就好几兆流量没了，更不用说频繁的心跳带来的电量损耗。

既然频繁心跳会带来耗电和耗流量的弊端，改进的方向自然是减少心跳频率，但也不能过于影响连接检测的实时性。基于这个需求，一般可以将心跳间隔根据程序状态进行调整，当程序在后台时(这里主要考虑安卓)，尽量拉长心跳间隔，5 分钟、甚至 10 分钟都可以。

而当 App 在前台时则按照原来规则操作。连接可靠性的判断也可以放宽，避免一次心跳超时就认为连接无效的情况，使用错误积累，只在心跳超时 n 次后才判定当前连接不可用。当然还有一些小 trick 比如从收到的最后一个指令包进行心跳包周期计时而不是固定时间，这样也能够一定程度减少心跳次数。

## 断线重连

### 关键1：快速感知何时需要重连

### 场景分析

1. 连接明确断开了
2. 连接没断但是不可用了
3. 连接对端的服务不可用了

第一种场景：最简单的，连接直接断开了，肯定需要重连

后两者：无论是连接不可用还是服务不可用，对上层应用的影响都是不能再收发即时消息了

**心跳包主动探测网路可用性**

感知何时需要重连的一种简单粗暴的方法就是通过心跳包超时：发送一个心跳包，如果在特定时间内还是没有收到服务器回包，则认为服务不可用。

如果需要快速感知，就只能多发心跳包，加快心跳频率。但是心跳太快对移动端流量、电量的消耗又会太多，所以使用这种方法没办法完美的做到快速感知，可以作为检测连接和服务可用的兜底机制。

**被动监听网络状态改变**

除了使用心跳检测，还可以通过判断网络状态来实现。

因为断网，切换WIFI，切换网络是导致连接不可用的最直接原因，所以在网络状态由offline变为online时，大多数情况下都需要重连。但是也不一定：

因为webscoket底层是基于TCP的，TCP连接不能敏锐的感知到应用层的网络变化，所以有时候即便网络断开了一小会，对WebSocket连接是不会有影响的，网络恢复后，仍然能够正常地进行通信。

因此在网络由断开到连接上时，立即判断下连接是否可用，可以通过发一个心跳包判断，如果能够正常收到服务器的心跳回包，则说明连接仍是可用的，如果等待超时后仍没有收到心跳回包，则需要重连。

这种方法的优点是速度快，在网络恢复后能够第一时间感知连接是否可用，不可用的话可以快速执行恢复，但它只能覆盖应用层网络变化导致WebSocket不可用的情况。

### 关键2：快速断开旧连接

**目的**

1. 释放客户端和服务器的资源
2. 避免之后误从旧连接收发数据

websocket底层是基于TCP协议传输数据的，连接两端分别是服务器和客户端，而TCP的TIME_WAIT状态是由服务器端维持的，因此在大多数情况下，应该由服务器端发起断开底层TCP连接，而不是客户端。

**具体如下：**

1. 当旧连接可用时，客户端可以直接给服务器发送断开信号，然后服务器发起断开连接即可
2. 当旧连接不可用时，比如客户端切换了wifi，客户端发送了断开信号，但是服务器收不到，客户端只能迟迟等待，直至超时才能被允许断开

超时断开的过程相对来说是比较久的，有没有办法可以快点断开？

上层应用无法改变 只能由服务器发起断开连接 这种协议层面的规则，所以只能层应用层入手，比如在上层通过业务逻辑保证旧连接完全失效，模拟连接断开，然后在发起新连接，恢复通讯。

这种方法相当于尝试断开连接不行时，直接弃之，然后就能快速进入下一流程，所以在使用时一定要确保在业务逻辑上旧连接已完全失效。

比如：

1. 保证丢掉从旧连接收到所有数据
2. 旧连接不能阻碍新连接的建立
3. 旧连接超时断开后不能影响新连接和上层业务逻辑等等

### 关键三：快速发起新连接

遇到因网络原因导致的重连时，是万万不能立即发起一次新连接的，否则当出现网络抖动时，所有的设备都会立即同时向服务器发起连接，这无异于黑客通过发起大量请求消耗网络带宽引起的拒绝服务攻击，这对服务器来说简直是灾难（服务端雪崩效应）

所以在重连时通常采用一些退避算法，延迟一段时间再发起重连

如果要快速连上呢？最直接的做法就是缩短重试间隔，重试间隔越短，在网络恢复后就能越快的恢复通讯。但是太频繁的重试对性能、带宽、电量的消耗就比较严重。

**如何在这之间做一个较好的权衡呢？**

1. 一种比较合理的方式是随着重试次数增多，逐渐增大重试间隔
2. 另一方面监听网络变化，在网络状态由offline变为online这种比较可能重连上的时刻，适当地减小重连间隔

除此之外，还可以结合业务逻辑，根据成功重连上的可能性适当的调整间隔，如网络未连接时或应用在后台时重连间隔可以调大一些，网络正常的状态下可以适当调小一些等等，加快重连上的速度。

### 断网重连逻辑细分为三个步骤

- 1）确定何时需要重连；
- 2）断开旧连接；
- 3）发起新连接。

然后分别分析了在WebSocket的不同状态下、不同的网络场景下，如何快速完成这个三个步骤。

**过程具体总结就是：**

- 1）通过定时发送心跳包的方式检测当前连接是否可用，同时监测网络恢复事件，在恢复后立即发送一次心跳，快速感知当前状态，判断是否需要重连；

  首先：

- 2）正常情况下由服务器断开旧连接，与服务器失去联系时直接弃用旧连接，上层模拟断开，来实现快速断开；

  其次：

- 3）发起新连接时使用退避算法延迟一段时间再发起连接，同时考虑到资源浪费和重连速度，可以在网络离线时调大重连间隔，在网络正常或网络由offline变为online时缩小重连间隔，使之尽可能快地重连上。

一些资源文章：

[WebSocket详解（一）：初步认识WebSocket技术-网页端IM开发/专项技术区 - 即时通讯开发者社区! (52im.net)](http://www.52im.net/thread-331-1-1.html)

[WebSocket详解（二）：技术原理、代码演示和应用案例-网页端IM开发/专项技术区 - 即时通讯开发者社区! (52im.net)](http://www.52im.net/thread-326-1-1.html)

[WebSocket详解（三）：深入WebSocket通信协议细节-网页端IM开发/专项技术区 - 即时通讯开发者社区! (52im.net)](http://www.52im.net/thread-332-1-1.html)

[WebSocket详解（四）：刨根问底HTTP与WebSocket的关系(上篇)-网页端IM开发/专项技术区 - 即时通讯开发者社区! (52im.net)](http://www.52im.net/thread-1258-1-1.html)

[WebSocket详解（五）：刨根问底HTTP与WebSocket的关系(下篇)-网页端IM开发/专项技术区 - 即时通讯开发者社区! (52im.net)](http://www.52im.net/thread-1266-1-1.html)

[WebSocket详解（六）：刨根问底WebSocket与Socket的关系-网页端IM开发/专项技术区 - 即时通讯开发者社区! (52im.net)](http://www.52im.net/thread-1273-1-1.html)

