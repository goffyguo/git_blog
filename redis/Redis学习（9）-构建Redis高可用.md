## 前言

我一直在想如何做到 Redis 的稳定、高可用，是不是那些骇人的概念（主从复制、哨兵、集群、分片。。。），那如何从最简单的一步一步构建出稳定、高性能的Redis集群呢？这方面的知识点该如何学习，一个一个点的学习不太能从整体视角审视这个问题，所以计划本文一次性说清楚这个问题（计划先用一段白话文说清楚每个阶段在干什么，为什么这么干。然后对于每一步拆开详细学习记录，最后总结），预计又是一篇万字长文，来吧！

## 一步一步构建稳定、高性能的 Redis

### 最简单的单机版 Redis

为了性能，为了读性能，引进了缓存（Redis）这个概念，从MySQL中查出数据，然后放到Redis里面，之后的业务就去Redis里面去取，看起来很好。

随着时间，业务数据的增大，Redis存储的数据越来越大，往Redis里面存储的数据也越来越重要，那么此时对Redis的依赖也越来越重。如果有一天Redis故障无法再提供服务，轻则无法保证部分业务数据的准确性，重则整个系统岌岌可危。

既然 Redis 只把数据存储在内存中，那是否可以把这些数据也写一份到磁盘上呢？如果采用这种方式，当 Redis 重启时，我们把磁盘中的数据快速**恢复**到内存中，这样它就可以继续正常提供服务了。是的，这是一个很好的解决方案，这个把内存数据写到磁盘上的过程，就是数据持久化。

### 数据持久化（RDB & AOF）：有备无患

首先，可以想到，持久化当然是持久到本地的磁盘上，最容易想到的一个方案就是Redis每一次执行写操作，，同时也写一份到磁盘上。这就是最简单、最直接的方案。但是，分析一下。如果每次客户端的写操作，既需要写内存，又需要写磁盘，而且写磁盘的耗时要比写内存的时间长的长的长，这肯定会拖慢Redis本来的性能。

所以，接下来可以这样优化：Redis 写内存由主线程来做，写内存完成后就给客户端返回结果，然后 Redis 用另一个线程去写磁盘，这样就可以避免主线程写磁盘对性能的影响。

除此之外，从Redis本身被设计的原因考虑（缓存），这就意味着尽管Redis中没有保存全量数据，对于不在缓存中的数据，依旧可以通过查询数据库后都回写Redis，只不过速度慢点，但是业务结果数据的准确性影响不大，基于这个特点，Redis的持久化还可以用数据快照的方式来做。

Redis 的数据快照，是记录某一时刻下 Redis 中的数据，然后只需要把这个数据快照写到磁盘上就可以了。它的优势在于，只在需要持久化时，把数据「一次性」写入磁盘，其它时间都不需要操作磁盘。基于这个方案可以定时给Redis做数据快照，把数据持久化道磁盘上。

上面说到的持久化方案其实就是 Redis 的 RDB 和 AOF。

当然，关于RDB和AOF下面具体再说，接着说做完持久化又会有什么新的问题。

即便把持久化优化的特别好，但别忘了，恢复总是需要时间的，在这期间业务还是会受到影响。

这个时候，就要用上主从复制了：一个实例宕机，只能用恢复数据处理，那是否可以部署多个Redis示例，然后让这些示例数据保持实时同步，这样当一个实例宕机时，就从剩下的示例中选择一个继续提供服务就好了。

### 主从复制：多副本

一般的主从复制会部署3台（一台master，两台slave），这样就是3个Redis示例。

采用多副本的优势：

1. 短期不可用时间：master 发生宕机，我们可以手动把 slave 提升为 master 继续提供服务
2. 提升读性能：让 slave 分担一部分读请求，提升应用的整体性能

这个方案看起来不错，不仅节省了数据恢复的时间，还能提升性能，那它有什么问题嘛？

当 master 宕机时，需要手动把 slave 提升为 master，这个过程也是需要花费时间的。

虽然比恢复数据要快得多，但还是需要人工介入处理。一旦需要人工介入，就必须要算上人的反应时间、操作时间，所以，在这期间你的业务应用依旧会受到影响。

是否可以把这个切换的过程，变成自动化呢？对于这种情况，就需要一个故障自动切换机制，这就是经常听到的哨兵所具备的能力。

### 哨兵：故障自动切换

现在，可以引入一个类似观察者的角色，让他实时检测master的健康状态，这个观察者就是哨兵。

1. 哨兵每间隔一段时间，询问 master 是否正常
2. master 正常回复，表示状态正常，回复超时表示异常
3. 哨兵发现异常，发起主从切换

有个这个方案，就不需要人工介入，可以让他们自动化的执行，但是还有一个问题，就是如果哨兵和master之间的网络发生了问题，那这个哨兵就有可能会误判。这个问题该怎么办？

可以部署多个哨兵，让它们分布在不同的机器上，它们一起监测 master 的状态，流程就变成了这样：

1. 多个哨兵每间隔一段时间，询问 master 是否正常
2. master 正常回复，表示状态正常，回复超时表示异常
3. 一旦有一个哨兵判定 master 异常（不管是否是网络问题），就询问其它哨兵，如果多个哨兵（设置一个阈值）都认为 master 异常了，这才判定 master 确实发生了故障
4. 多个哨兵经过协商后，判定 master 故障，则发起主从切换

所以，我们用多个哨兵互相协商来判定 master 的状态，这样一来，就可以大大降低误判的概率。

哨兵协商判定 master 异常后，这里还有一个问题：**由哪个哨兵来发起主从切换呢？**

答案是，选出一个哨兵「领导者」，由这个领导者进行主从切换。

问题又来了，这个领导者怎么选？

想象一下，在现实生活中，选举是怎么做的？是的，投票。

在选举哨兵领导者时，可以制定这样一个选举规则：

1. 每个哨兵都询问其它哨兵，请求对方为自己投票
2. 每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次
3. 首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换

其实，这个选举的过程就是我们经常听到的：分布式系统领域中的共识算法。

> 共识算法：在分布式系统领域，多个节点如何就一个问题达成共识的算法，就叫共识算法
>
> 通过特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识

现在，我们用多个哨兵共同监测 Redis 的状态，这样一来，就可以避免误判的问题了。

到这里，看着问题一点点意思了，从简单的单机版，经过数据持久化、主从多副本、哨兵集群，这一路优化下来，你的 Redis 不管是性能还是稳定性，都越来越高，就算节点发生故障，也不用担心了。但是这样就没有问题了吗？

继续分析：

1. 稳定性：Redis 故障宕机，我们有哨兵 + 副本，可以自动完成主从切换
2. 性能：读请求量增长，我们可以再部署多个 slave，读写分离，分担读压力
3. 性能：写请求量增长，但我们只有一个 master 实例，这个实例达到瓶颈怎么办？

到了么，如果写请求量越来越大时，一个 master 实例可能就无法承担这么大的写流量了。想要完美的解决这个问题，此时就要考虑使用集群分片了。

### 分片集群：横向扩展

什么是分片集群？

简单来讲，一个实例扛不住写压力，那可以部署多个实例，然后把这些实例按照一定规则组织起来，把它们当成一个整体，对外提供服务，这样不就可以解决集中写一个实例的瓶颈问题吗？

关于分片集群的详细问题下面再专门学习。

至此，Redis 已经很稳定和高可用了，这也就业界给出的答案。

## 简单总结

首先，在使用最简单的单机版 Redis 时，发现当 Redis 故障宕机后，数据无法恢复的问题，因此想到了数据持久化，把内存中的数据也持久化到磁盘上一份，这样 Redis 重启后就可以从磁盘上快速恢复数据。

在进行数据持久化时，又面临如何更高效地将数据持久化到磁盘的问题。之后发现 Redis 提供了 RDB 和 AOF 两种方案，分别对应了数据快照和实时的命令记录。如果对数据完整性要求不高时，可以选择 RDB 持久化方案。如果对于数据完整性要求较高，那么可以选择 AOF 持久化方案。

但是又发现，AOF 文件体积会随着时间增长变得越来越大，此时想到的优化方案是，使用 AOF rewrite 的方式对其进行瘦身，减小文件体积，再后来，发现可以结合 RDB 和 AOF 各自的优势，在 AOF rewrite 时使用两者结合的「混合持久化」方式，又进一步减小了 AOF 文件体积。

之后，发现尽管可以通过数据恢复的方式还原数据，但恢复数据也是需要花费时间的，这意味着业务应用还是会受到影响。进一步优化，采用多副本的方案，让多个实例保持实时同步，当一个实例故障时，可以手动把其它实例提升上来继续提供服务。

但是这样也有问题，手动提升实例上来，需要人工介入，人工介入操作也需要时间，开始想办法把这个流程变得自动化，所以又引入了哨兵集群，哨兵集群通过互相协商的方式，发现故障节点，并可以自动完成切换，这样就大幅降低了对业务应用的影响。

最后，把关注点聚焦在如何支撑更大的写流量上，所以，又引入了分片集群来解决这个问题，让多个 Redis 实例分摊写压力，未来面对更大的流量，还可以添加新的实例，横向扩展，进一步提升集群的性能。

至此，如此构建的Redis 集群才得以长期稳定、高性能的为业务提供服务。

## 思考

上面专门说了如何通过Redis构建一个稳定、高性能的集群，其实，这就是架构设计的核心思想：

- 高性能：读写分离、分片集群
- 高可用：数据持久化、多副本、故障自动切换
- 易扩展：分片集群、横向扩展

而且，关于哨兵集群、分片集群，其实还提到了一些关于分布式系统的相关知识：

- 分布式共识：哨兵领导者选举
- 负载均衡：分片集群数据分片、数据路由

其实，对与Redis是这样，构建任何一个数据集群，都可以沿用这个思考去思考，去优化。

在做软件架构设计时，面临的场景就是发现问题、分析问题、解决问题，一步步去演化、升级架构，最后在性能、可靠性方面达到一个平衡。虽然各种软件层出不穷，但架构设计的思想不会变，只要真正掌握这一套思想，才会学有所获。下面，开始挨个攻破上面提到的这些知识点。

## RDB、AOF



## 主从复制



## 哨兵





## 分片集群





## 总结

