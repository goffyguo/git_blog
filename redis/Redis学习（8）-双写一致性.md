只要你使用了缓存，就避不开一个问题：如何保证缓存和数据库的数据一致性？而这个问题又牵扯出很多问题，而且细节之处非常多，这篇文章总结下关于双写一致性的方方面面。

## 缓存双写一致性的理解

简单两句话：如果Redis中有数据，需要和数据库中的值相同；如果Redis中无数据，数据库中的值要是最新值。

要做缓存一致性，无非就是针对写（增加、更新）操作（删除在这里没什么意思），应该形成一个共识就是缓存是在数据库的上层，数据库作为数据兜底来用，所以绝对不能第一步就是删除数据库，这种原则上的错误是不能允许的，基于这个前提，分析下剩下的几种方案利弊，最终选择出最适合的那一种。

首先明确一点，造成数据不一致的情况大的分两种情况：操作失败和并发。所以下面的分析都会说到这两点。当然如果讨论并发当然是在前两步都可以成功执行的情况下讨论。

## 先更新数据库，后更新缓存

### 操作失败

如果数据库更新成功了，但缓存更新失败，那么此时数据库是最新值，缓存中是旧值。之后的读请求都是请求到的旧值，那么当缓存失效后，才能看到最新的值，造成数据不一致的现象。

可见，无论先更新谁好像都有问题，而且这只是在操作失败的逻辑下分析的，如果再加入并发问题，又会对一致性造成什么影响呢？

### 并发

有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：

1. 线程 A 更新数据库（X = 1）
2. 线程 B 更新数据库（X = 2）
3. 线程 B 更新缓存（X = 2）
4. 线程 A 更新缓存（X = 1）

最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。

也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。

同样的，先更新缓存、后更新数据的并发产生的问题同理，下面将不再讨论。

## 先更新缓存，后更新数据库

### 操作失败

如果缓存更新成功了，但是数据库更新失败，那么此时缓存中是最新值，但是数据库中是旧值。

虽然此时读请求可以命中缓存，拿到最新的值，但是一旦发生缓存失效（缓存删除或者过期时间到），就会从数据库中读到旧值，会写缓存也变成这个旧值，造成数据不一致的现象。

### 并发

同先更新数据库，后更新缓存并发产生的问题同理。

到这里分析了更新数据库+更新缓存的方案，如果再多思考一点，从缓存利用率这一点上思考，发现更新的这种方案貌似也有很大问题。

每次数据变更，都无脑更新缓存，但是缓存中的数据不一定马上就会读取，这就会导致缓存中可能存放不了很多不常访问的数据，浪费缓存资源。而且，很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列计算得出一个值，才把这个值放到缓存中。那这样，更新这种方案明显就有很大问题。

所以，开始分析另外一种方案。

## 先删除缓存、后更新数据库

根据前面的分析，明确但凡第二步失败，都会导致数据不一致，所以操作失败的场景就不再分析，只分析由于并发产生的数据不一致的问题。

如果有 2 个线程要并发「读写」数据，可能会发生以下场景：

1. 线程 A 要更新 X = 2（原值 X = 1）
2. 线程 A 先删除缓存
3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
4. 线程 A 将新值写入数据库（X = 2）
5. 线程 B 将旧值写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。

可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。

## 先更新数据库、后删除缓存

依旧是 2 个线程并发「读写」数据：

1. 缓存中 X 不存在（数据库 X = 1）
2. 线程 A 读取数据库，得到旧值（X = 1）
3. 线程 B 更新数据库（X = 2)
4. 线程 B 删除缓存
5. 线程 A 将旧值写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。

这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？

其实概率「很低」，这是因为它必须满足 3 个条件：

1. 缓存刚好已失效
2. 读请求 + 写请求并发
3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）

仔细想一下，条件 3 发生的概率其实是非常低的。

因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。

这么来看，「先更新数据库 + 再删除缓存」的方案，在**一定情况下**是可以保证数据一致性的。

所以，生产环境中一般采用这种方案，来操作数据库和缓存。

好，解决了并发问题，上面还留着一个很大的问题，**第二步执行「失败」导致数据不一致的问题**。

## 综合分析，普遍存在的问题

如何保证两步都执行完成？

### 异步重试

为什么不是同步重试？

如果在操作失败后就无脑重试，那就真的很无脑，因为现实情况中不是想象中的那么简单，如果同步重试，会有以下几个问题：

- 立即重试很大概率还会失败
- 重试次数设置多少合理
- 重试会一直占用这个线程资源，无法服务其他客户端请求

所以，应该考虑异步重试。

#### 消息队列

把请求写到消息队列中，然后由专门的消费者来重试，直到成功。

在生产环境中，一般都会这么做：

为了避免第二步执行失败，把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。为什么这么做？写消息队列也有可能会失败啊，而且，引入消息队列，增加了更多的维护成本，看起来好像并不好。

是这样的，在讨论消息队列解决异步重试这个问题时，系统一定是已经引入了消息队列，这样，把这个功能放进去时，才不能单纯因为这一个功能就引进一个中间件，再者，为什么会把这个操作也放到另一个服务（消息队列）中，是因为如果在执行失败的线程中一直重试，还没等到执行成功时，此时项目重启了，那这个重试请求丢失，也不会在重试这次的请求了，所以把这个操作（重试和第二步操作）直接放到一个服务中，正好符合对消息队列的需求场景定义：

- **消息队列保证可靠性**：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）
- **消息队列保证消息成功投递**：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）

如果系统中没有引进消息队列，那就不要单纯为了这个引进消息队列，采用日志订阅的方案解决这个问题。

#### 日志订阅

MySQL 有一个 Binlog 的功能，当一条数据发生变更时，MySQL 就会产生一条变更日志（Binlog）。那么可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。

对于这样的方案，业界已经有了比较常用的开源中间件，例如阿里的 canal ，使用这种方案的优点在于：

- **无需考虑写消息队列失败情况**：只要写 MySQL 成功，Binlog 肯定会有
- **自动投递到下游队列**：canal 自动把数据库变更日志「投递」给下游的消息队列

当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。

到这里，可以得出结论，想要保证数据库和缓存一致性，**推荐采用先更新数据库，再删除缓存方案，并配合消息队列或订阅变更日志的方式来做**。

## 缓存延迟双删策略

还有一个问题，是需要注意的，用一个场景举例：（这里只用先更新数据库，再删除缓存这种方案引入这个问题，上面的方案均存在下面要说的这个问题）

1. 线程 A 更新主库 X = 2（原值 X = 1）
2. 线程 A 删除缓存
3. 线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）
4. 从库「同步」完成（主从库 X = 2）
5. 线程 B 将「旧值」写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。

这就是典型的由于在读写分离+主从复制延迟情况下，缓存的都被会写了旧值。

所以，需要把缓存删掉。但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：**缓存延迟双删策略**（删掉缓存，这样下次就可以直接从数据读取到最新数据，写入缓存）。

但是，这个延迟删除策略，延迟时间到底要设置多久？

在分布式系统中，这样单纯没有任何依据的评估时间是非常困难的，很多时候，只能凭借经验大致估算这个延迟时间。所以，采用这种情况，也只是尽可能的保证一致性而已，计算情况下，还是有可能发生不一致。

所以在实际生产中，建议采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证主从复制不要有太大延迟，降低出问题的概率。

## 强一致性 OR 最终一致性？

其实，做到强一致性太难，但是也可以，比如常见的协议（2PC、3PC、Paxos、Raft），但是它们的性能非常差，而且方案复杂，还有考虑各种容错的问题。思考到这，需要返回去从头开始：

使用缓存的目的是什么？性能

一旦决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。

而且，就拿前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到中间状态的数据。

所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有任何请求进来。

虽然可以通过加分布锁的方式来实现，但付出的代价，很可能会超过引入缓存带来的性能提升。

所以，既然决定使用缓存，就必须容忍一致性问题，只能尽可能地去降低问题出现的概率。

同时也要知道，缓存都是有失效时间的，就算在这期间存在短期不一致，依旧有失效时间来兜底，这样也能达到最终一致。

## 总结

### 方案总结

1. 缓存一致性的方案：先更新数据库 + 更新缓存、更新数据库 + 删除缓存
2. 更新数据库 + 更新缓存方案，在并发场景下无法保证缓存和数据一致性，且存在缓存资源浪费和机器性能浪费的情况发生
3. 在更新数据库 + 删除缓存的方案中，先删除缓存，再更新数据库在并发场景下依旧有数据不一致问题，解决方案是延迟双删，但这个延迟时间很难评估，所以推荐用先更新数据库，再删除缓存的方案
4. 在先更新数据库，再删除缓存方案下，为了保证两步都成功执行，需配合消息队列或订阅变更日志的方案来做，本质是通过重试的方式保证数据一致性
5. 在先更新数据库，再删除缓存方案下，读写分离 + 主从库延迟也会导致缓存和数据库不一致，缓解此问题的方案是延迟双删，凭借经验发送延迟消息到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率

### 心得总结

1. 性能和一致性不能同时满足，为了性能考虑，通常会采用最终一致性的方案
2. 掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题
3. 失败场景下要保证一致性，常见手段就是重试，同步重试会影响吞吐量，所以通常会采用异步重试的方案
4. 订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致

所以，到最后，其实会发现，很多一致性的问题，都会采用这些方案和这种思想来解决，万变不离其宗。













